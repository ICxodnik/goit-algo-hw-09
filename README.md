### В проекті 
- реалізація жадібних алгоритмів та алгоритмів динамічного програмування;
- розробка функцій жадібного алгоритму та алгоритму динамічного програмування;
- об'єктивний аналіз, який метод може бути ефективнішим у конкретних умовах.

### Порівняння 
##### Порівняння для суми 113:
- Жадібний алгоритм: {50: 2, 10: 1, 2: 1, 1: 1}, загальна кількість монет: 5, час: 0.000009 сек
- Динамічне програмування: {1: 1, 2: 1, 10: 1, 50: 2}, загальна кількість монет: 5, час: 0.000803 сек

##### Порівняння для суми 378:
- Жадібний алгоритм: {50: 7, 25: 1, 2: 1, 1: 1}, загальна кількість монет: 10, час: 0.000003 сек
- Динамічне програмування: {1: 1, 2: 1, 25: 1, 50: 7}, загальна кількість монет: 10, час: 0.001695 сек

##### Порівняння для суми 999:
- Жадібний алгоритм: {50: 19, 25: 1, 10: 2, 2: 2}, загальна кількість монет: 24, час: 0.000003 сек
- Динамічне програмування: {2: 2, 10: 2, 25: 1, 50: 19}, загальна кількість монет: 24, час: 0.004907 сек

##### Порівняння для суми 10000:
- Жадібний алгоритм: {50: 200}, загальна кількість монет: 200, час: 0.000004 сек
- Динамічне програмування: {50: 200}, загальна кількість монет: 200, час: 0.055946 сек

##### Порівняння для суми 37033:
- Жадібний алгоритм: {50: 740, 25: 1, 5: 1, 2: 1, 1: 1}, загальна кількість монет: 744, час: 0.000005 сек
- Динамічне програмування: {1: 1, 2: 1, 5: 1, 25: 1, 50: 740}, загальна кількість монет: 744, час: 0.195058 сек

### Результати 
- Результат виконання для двух алгоритмів на тестових данних виявився однаковим.
- Час виконання алгоритмів значно відрізняються
  
#### Жадібний алгоритм:

- Простий і швидкий (O(n), де n — кількість номіналів).

- Працює ідеально, якщо набір монет дозволяє завжди будувати оптимальне рішення.

#### Динамічне програмування:

- Складність O(amount * n), де amount — сума, а n — кількість номіналів.

- Завжди знаходить оптимальне (мінімальне) рішення.

- Повільніше для великих сум, але гарантує точність.
